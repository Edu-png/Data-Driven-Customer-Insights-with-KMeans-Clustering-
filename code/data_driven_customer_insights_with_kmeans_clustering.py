# -*- coding: utf-8 -*-
"""Data-Driven Customer Insights with KMeans Clustering

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15xqOPlSFaKC5bemTh1Qamgbar8pABpUD

# Data-Driven Customer Insights with KMeans Clustering

## Sobre a base de dados e o projeto:

Este projeto tem como objetivo aplicar o algoritmo de KMeans Clustering para segmentação de clientes com base em seus comportamentos e padrões de compra. Utilizando bibliotecas populares do Python, como Pandas, Scikit-learn, e Matplotlib, o projeto demonstra como preparar os dados, escolher o número ideal de clusters usando o Elbow Method e interpretar os resultados para gerar insights valiosos para negócios.

Inspiração: https://www.youtube.com/watch?v=afPJeQuVeuY

Data-set: https://archive.ics.uci.edu/dataset/502/online+retail+ii

Online Retail Mining Whitepaper: https://link.springer.com/article/10.1057/dbm.2012.17

O dataset utilizado no projeto contém dados sobre clientes, incluindo variáveis como idade, renda anual e pontuação de gastos em uma loja. Ele é amplamente usado em análises de segmentação para identificar perfis distintos de consumidores. A partir dessas variáveis, o KMeans Clustering pode agrupar os clientes em clusters com base em semelhanças, permitindo identificar padrões de comportamento. Esse tipo de análise é útil em estratégias de marketing personalizadas, ajudando empresas a compreender melhor seus clientes e otimizar ofertas de produtos e serviços conforme os perfis identificados.

## 1. Importando as bibliotecas
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler

"""## 2. Baixando o data-set:"""

# Previamente carregado no meu collab

df = pd.read_excel('/content/online_retail_II.xlsx') # Formato de excel é um pouco mais pesado, e portanto demora mais

df.head(10)

"""## 3. Explorando os dados

"""

# Informações gerais sobre o data-set:
df.info()


# Vemos que as colunas 'Description' e 'Customer ID' apresentam valores ausentes quando comparadas as outras.
# Podemos perceber também que a coluna 'InvoiceDate' já está em formato de tempo, o que é muito bom!

df.describe()

# Algo estranho de notar é o valor de quantity (min) sendo negativo, o mesmo também ocorre para 'Price', vamos investigar isso posteriomente.
# Outra coisa a se perceber é que por padrão aqui estão apenas os valores numéricos e não os do tipo objeto.

# Vendo os objetos:

df.describe(include = 'O')

# Esse parece ok, os valores não me geram nenhuma estranheza.

# Vamos dar uma olhada nos valores faltantes ['CustomerID']:

df[df["Customer ID"].isna()].head(10)

# Vemos que '85123a mixed', '21733 mixed' e 'short' apresentam valores negativos com preço igual a 0.
# Esses parecem dados válidos de serem eliminados!

# Na realidade, tendo em vista que estamos clusterizando os clientes, e é impossível repor os valores faltando nessa coluna, uma boa abordagem é excluir os valores que estão como faltantes nela:
# Iremos fazer isso em breve!

# Vamos dar uma olhada especificamente nos valores negativos para compreender eles melhor:

df[df['Quantity'] < 0].head(10)

# Podemos reparar que grande parte desses valores possui um 'C' a frente da sequência em invoice.
# Na descrição dos dados somos informados que C é para produtos Cancelados!

# Vamos olhar esses dados de Cancelados usando Regex:

df['Invoice'] = df['Invoice'].astype('str')
df[df['Invoice'].str.match("^\\d{6}$") == False]
# Pegando as colunas onde não são exatos 6 digitos, como diz a expressão!

# Será que o C é a única letra possível de aparecer na frente do 'Invoice'?

df['Invoice'].str.replace('[0-9]', '', regex = True).unique()

# Vemos que temos também um A, que é inesperado, pois não está no index dos dados!

# Apenas os valores iniciados com A
df[df['Invoice'].str.startswith('A')]
# Vemos que eles correspondem a categoria 'Adjust bad debt'
# Também são possíveis valores para excluir

# Inspecionando a coluna 'StockCode':

# Na descrição dos dados, vemos que são valores compostos por A-5 digitos designada para cada produto distinto, vamos ver se é verdade:

df['StockCode'] = df['StockCode'].astype('str')
df[df['StockCode'].str.match('^\\d{5$}$') == False]

# Voltamos uma lista de valores que não corespondem a isso, mas eles não parecem ter nada errado além disso, sendo valores válidos!

df[(df['StockCode'].str.match('^\\d{5$}$') == False) & (df['StockCode'].str.match('^\\d{5$}[a-zA-z]$') == False)]

# Vemos que temos muitos valores que não seguem esse padrão

# Retornando os valores unicos:

df[(df['StockCode'].str.match('^\\d{5$}$') == False) & (df['StockCode'].str.match('^\\d{5$}[a-zA-z]$') == False)]['StockCode'].unique()

# Vamos olhar especificamente e de forma manual cada um desses valores:

df[df['StockCode'].str.contains('^DOT')]

# No caso de DOT por exemplo, não é útil usar esses dados pois não temos 'CustomerID'

"""Resumindo os dados de todos eles em formato de tabela, temos:

| Code            | Description                                                                            | Action               |
|-----------------|----------------------------------------------------------------------------------------|----------------------|
| DCGS            | Looks valid, some quantities are negative though and customer ID is null               | Exclude from clustering |
| D               | Looks valid, represents discount values                                                | Exclude from clustering |
| DOT             | Looks valid, represents postage charges                                                | Exclude from clustering |
| M or m          | Looks valid, represents manual transactions                                            | Exclude from clustering |
| C2              | Carriage transaction - not sure what this means                                        | Exclude from clustering |
| C3              | Not sure, only 1 transaction                                                          | Exclude              |
| BANK CHARGES or B| Bank charges                                                                          | Exclude from clustering |
| S               | Samples sent to customer                                                              | Exclude from clustering |
| TESTXXX         | Testing data, not valid                                                                | Exclude from clustering |
| gift__XXX       | Purchases with gift cards, might be interesting for another analysis, but no customer data | Exclude             |
| PADS            | Looks like a legit stock code for padding                                              | Include              |
| SP1002          | Looks like a special request item, only 2 transactions, 3 look legit, 1 has 0 pricing  | Exclude for now      |
| AMAZONFEE       | Looks like fees for Amazon shipping or something                                       | Exclude for now      |
| ADJUSTX         | Looks like manual account adjustments by admins                                        | Exclude for now      |

Resumidamente, vamos usar apenas 'PADS', que parece válida, o resto será excluiído!

## 4. Limpando os dados:
"""

# Vamos criar uma cópia para poder realizar a limpeza dos dados:

cleaned_df = df.copy()

# Limpando a coluna 'Invoice':

cleaned_df['Invoice'] = cleaned_df['Invoice'].astype('str')

# Criando uma máscara, que é basicamente uma variável para filtrar dados:

mask = (
    cleaned_df['Invoice'].str.match('^\\d{6}$') == True
)

cleaned_df = cleaned_df[mask]

cleaned_df

# Com isso, excluimos todos os 'Invoices' que não seguem o padrão que comentamos antes.

# Fazendo a mesma coisa para a coluna 'StockCode':

cleaned_df['StockCode'] = cleaned_df['StockCode'].astype('str')

# Criando uma máscara, que é basicamente uma variável para filtrar dados:

mask = (
    (cleaned_df['StockCode'].str.match('^\\d{5}$') == True) # Apenas 5 digitos (padrão)
    | (cleaned_df['StockCode'].str.match('^\\d{5}[a-zA-Z]$') == True) # or 5 digitos seguindos de letras
    | (cleaned_df['StockCode'].str.match('^PADS$') == True) # or a PADS que verificamos ser a que faz sentido manter

    # Agora o padrão é o que vimos para StockCode!
)

cleaned_df = cleaned_df[mask]

cleaned_df

# Com isso, excluimos todos os 'StockCodes' que não seguem o padrão que comentamos antes.

# Vamos ver se com isso o preço negativo foi corrigido junto:

cleaned_df.describe()

# Vemos que não foi o caso, então precisamos arrumar isso também!
# Price agora está 0 e quantity apresenta valor negativo ainda

# Vamos eliminar os valores nulos:

cleaned_df.dropna(subset = ['Customer ID'], inplace = True)

cleaned_df.describe()
# Com isso, é possível perceber que eliminamos o problema dos valores negativos!

# Conferindo os preços iguais a 0:

cleaned_df[cleaned_df['Price'] == 0]

# Não sabemos exatamente o que são esses preços 0, se são por exemplo itens grátis, mas de toda forma não são válidos de serem adicionados ao nosso modelo!

len(cleaned_df[cleaned_df['Price'] == 0])
# Vendo o tamanho, podemos reparar que são apenas 28 valores, então realmente não é um problema excluir!

cleaned_df = cleaned_df[cleaned_df['Price'] > 0]

cleaned_df.describe()

# Vemos que o valor ainda está 0 mesmo tendo sido apagado, vamos conferir melhor isso:

cleaned_df['Price']. min()

# Vemos que há valores bem baixos próximos a 0, como 0,001.
# Nesse caso, vamos deixar da forma que está

# Agora que terminamos a parte de limpar, quanto dados 'perdemos'?

(len(cleaned_df)/ len(df))*100

# Sobrou cerca de 77% do total de dados que tinhamos ao iniciar o processo de cleaning!

"""## 5. Feature engineering:"""

# Criando uma coluna para total de transações:

cleaned_df['SalesLineTotal'] = cleaned_df['Quantity']*cleaned_df['Price']
cleaned_df

# Vemos agora uma coluna de total!

# Vamos agregar os nossos dados por Cliente, ou seja, pelo 'CustomerID':
# Esse data-frame vai ter algumas novas colunas:
# MonetaryValue, Frequency

agg_df = cleaned_df.groupby(by = 'Customer ID', as_index = False) \
  .agg(
      MonetaryValue = ('SalesLineTotal', 'sum'),
      Frequency = ('Invoice', 'nunique'),
      LastInvoiceData = ('InvoiceDate', 'max')
  )

agg_df.head(10)

"""
A coluna Recency representa o número de dias desde a última compra feita por cada cliente até a data mais recente de faturamento no dataset.

Esse conceito é utilizado na análise RFM (Recency, Frequency, Monetary Value) para entender o comportamento dos clientes em termos de:

Recency (Recência): Quando foi a última compra do cliente?
Frequency (Frequência): Com que frequência o cliente faz compras?
Monetary Value (Valor Monetário): Quanto o cliente gasta em média?"""

# Criando a coluna 'Recency':

max_invoice_date = agg_df['LastInvoiceData'].max()
max_invoice_date

agg_df['Recency'] = (max_invoice_date - agg_df['LastInvoiceData']).dt.days # em dias

agg_df.head(10)

# Sabendo que outliers podem ser um problema para o nosso modelo, vamos tentar ldiar com eles:

# Plotando todos as variáveis com histogramas:

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
plt.hist(agg_df['MonetaryValue'], bins=10, color='skyblue', edgecolor='black')
plt.title('Monetary Value Distribution')
plt.xlabel('Monetary Value')
plt.ylabel('Count')

plt.subplot(1, 3, 2)
plt.hist(agg_df['Frequency'], bins=10, color='lightgreen', edgecolor='black')
plt.title('Frequency Distribution')
plt.xlabel('Frequency')
plt.ylabel('Count')

plt.subplot(1, 3, 3)
plt.hist(agg_df['Recency'], bins=20, color='salmon', edgecolor='black')
plt.title('Recency Distribution')
plt.xlabel('Recency')
plt.ylabel('Count')

plt.tight_layout()
plt.show()

"""Nos podemos ver que nos dois primeiros casos, temos alguns poucos outliers, grande parte dos dados está nas primeiras volunas. Por outro lado, a coluna de 'Recency' parece estar dentro dos padrões que esparamos."""

# Usando um boxplot para investigar melhor os outliers:

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
sns.boxplot(data=agg_df['MonetaryValue'], color='skyblue')
plt.title('Monetary Value Boxplot')
plt.xlabel('Monetary Value')

plt.subplot(1, 3, 2)
sns.boxplot(data=agg_df['Frequency'], color='lightgreen')
plt.title('Frequency Boxplot')
plt.xlabel('Frequency')

plt.subplot(1, 3, 3)
sns.boxplot(data=agg_df['Recency'], color='salmon')
plt.title('Recency Boxplot')
plt.xlabel('Recency')

plt.tight_layout()
plt.show()

"""Confirmando o que vimos anteriormente, temos grande parte dos valores em uma faixa única para as duas primeiras variáveis e alguns outliers muito fora disso, já a 3 temos uma quantidade menor de outliers, o que condiz com a sua distribuição.

Como os outliers nesse caso são extremamente importantes, pois representam clientes que gastaram muito e frequententemente, nós não podemos simplesmente remover eles, eles são os mais valiosos! Por isso vamos separar os dois e conduzir duas analises separadas.
"""

# Vamos separar os alcances dos quartis:
# Monetary Value:
M_Q1 = agg_df['MonetaryValue'].quantile(0.25) # 1 quartil corresponde a 25% dos dados.
M_Q1

M_Q3 = agg_df['MonetaryValue'].quantile(0.75) # 3 quartil corresponde a 75% dos dados.
M_Q3

# Alcance interquartilico:

M_IQR = M_Q3 - M_Q1
M_IQR

# Pegando todos os dados desse intervalo:

#top_range
monetary_outliers_df = agg_df[(agg_df['MonetaryValue'] > (M_Q3 + 1.5* M_IQR)) | (agg_df['MonetaryValue'] < (M_Q1 - 1.5 * M_IQR))].copy()
#botton_range - Não acho que vá ter pois a maioria dos dados é abaixo mais vamos adicionar

monetary_outliers_df.describe()

# Fazendo isso para FrequencyValues:


F_Q1 = agg_df['Frequency'].quantile(0.25)
F_Q3 = agg_df['Frequency'].quantile(0.75)
F_IQR = F_Q3 - F_Q1

frequency_outliers_df = agg_df[(agg_df['Frequency'] > (F_Q3 + 1.5 * F_IQR)) | (agg_df['Frequency'] < (F_Q1 - 1.5 * F_IQR))].copy()

frequency_outliers_df.describe()

# Criando um novo df para os dados que não são outliers:

non_outliers_df = agg_df[(~agg_df.index.isin(monetary_outliers_df.index)) & (~agg_df.index.isin(frequency_outliers_df.index))]

non_outliers_df.describe()

# Vemos que embora ainda tenha uma certa variabilidade, já está bem melhor do que antes!

# Plotando o box plot para esses dados (sem outliers):

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
sns.boxplot(data=non_outliers_df['MonetaryValue'], color='skyblue')
plt.title('Monetary Value Boxplot')
plt.xlabel('Monetary Value')

plt.subplot(1, 3, 2)
sns.boxplot(data=non_outliers_df['Frequency'], color='lightgreen')
plt.title('Frequency Boxplot')
plt.xlabel('Frequency')

plt.subplot(1, 3, 3)
sns.boxplot(data=non_outliers_df['Recency'], color='salmon')
plt.title('Recency Boxplot')
plt.xlabel('Recency')

plt.tight_layout()
plt.show()

# Vemos que ainda há alguns outliers, mas está muito mais tolerável do que antes!

# Plotando um gráfico em 3 dimensões desses dados:

fig = plt.figure(figsize=(8, 8))

ax = fig.add_subplot(projection="3d")

scatter = ax.scatter(non_outliers_df["MonetaryValue"], non_outliers_df["Frequency"], non_outliers_df["Recency"])

ax.set_xlabel('Monetary Value')
ax.set_ylabel('Frequency')
ax.set_zlabel('Recency')

ax.set_title('3D Scatter Plot of Customer Data')

plt.show()

# Essa visualização é muito importante para ter uma noção de como esses gráficos serão clusterizados!

# Repare que o matplotlib já coloca em uma escala, mas para o K-means, a gente precisa deixar isso mais claro para que funcione melhor!

"""## 6. Criando escalas para os dados

## Vamos usar o Standard Scaling

Escalonamento padrão (Standard Scaling) transforma as características (features) dos seus dados para terem uma média de 0 e um desvio padrão de 1, garantindo que cada característica contribua igualmente para a análise.

A fórmula utilizada para o escalonamento padrão é:

<center>
<img src="data:image/png;base64,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" alt="Formula de Standard Scaling">
</center>

### Onde:
- **z** é o valor padronizado,
- **x** é o valor original,
- **μ** é a média da característica,
- **σ** é o desvio padrão da característica.
"""

scaler = StandardScaler()

scaled_data = scaler.fit_transform(non_outliers_df[['MonetaryValue', 'Frequency', 'Recency']])

scaled_data

# Agora vemos que todos os nossos dados estão de fato, na mesma escala

# Convertendo o array em data frame novamente:

scaled_data_df = pd.DataFrame(scaled_data, index = non_outliers_df.index, columns = ('MonetaryValue', 'Frequency', 'Recency'))

scaled_data_df

# Plotando novamente os dados, mas em escala:

fig = plt.figure(figsize=(8, 8))

ax = fig.add_subplot(projection="3d")

scatter = ax.scatter(scaled_data_df["MonetaryValue"], scaled_data_df["Frequency"], scaled_data_df["Recency"])

ax.set_xlabel('Monetary Value')
ax.set_ylabel('Frequency')
ax.set_zlabel('Recency')

ax.set_title('3D Scatter Plot of Customer Data')

plt.show()

"""## 7. K-means clustering:"""

# Vamos testar varios valores de K e ver com base na inercia, qual seria o melhor valor para K;

max_k = 12
inertia = []

k_values = range(2, max_k + 1)

for k in k_values:

  kmeans = KMeans(n_clusters = k, random_state = 42, max_iter = 1000)

  kmeans.fit_predict(scaled_data_df)

  inertia.append(kmeans.inertia_)

plt.figure(figsize=(14,6))

plt.plot(k_values, inertia, marker = 'o')
plt.title('KMeans Inertia for Different Values of k')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia')
plt.xticks(k_values)
plt.grid(True)

plt.tight_layout()
plt.show()

"""O gráfico apresentado mostra a inércia do KMeans para diferentes valores de k (número de clusters) e é utilizado para determinar o número ideal de clusters por meio do método do "cotovelo". A inércia representa a soma das distâncias quadradas entre cada ponto de dados e o centróide mais próximo. Observa-se que, à medida que k aumenta, a inércia diminui, pois os clusters se tornam mais específicos e próximos dos dados. No entanto, essa redução na inércia começa a desacelerar significativamente em torno de k = 4, indicando o ponto de cotovelo. Esse ponto é geralmente considerado o número ideal de clusters, pois balanceia a compactação dos clusters com a simplicidade do modelo, evitando a sobresegmentação dos dados. Portanto, com base no gráfico, o número ideal de clusters parece ser entre 4 e 5.

Para decididr entre 4 e 5, nos usamos o Silhouette Score:

A pontuação de silhueta é calculada usando a seguinte fórmula:

![image.png](data:image/png;base64,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)

Onde:
s(i) é a pontuação de silhueta para uma única amostra i;
a(i) é a distância média entre i e todos os outros pontos no mesmo cluster;
b(i) é a distância média mínima entre i e todos os pontos no cluster mais próximo ao qual i não pertence.
A pontuação de silhueta varia entre [-1, 1], sendo que valores mais altos indicam clusters mais distintos e bem definidos.
"""

max_k = 12

inertia = []
silhoutte_scores = []
k_values = range(2, max_k + 1)

for k in k_values:

    kmeans = KMeans(n_clusters=k, random_state=42, max_iter=1000)

    cluster_labels = kmeans.fit_predict(scaled_data_df)

    sil_score = silhouette_score(scaled_data_df, cluster_labels)

    silhoutte_scores.append(sil_score)

    inertia.append(kmeans.inertia_)

plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(k_values, inertia, marker='o')
plt.title('KMeans Inertia for Different Values of k')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Inertia')
plt.xticks(k_values)
plt.grid(True)

plt.subplot(1, 2, 2)
plt.plot(k_values, silhoutte_scores, marker='o', color='orange')
plt.title('Silhouette Scores for Different Values of k')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Silhouette Score')
plt.xticks(k_values)
plt.grid(True)

plt.tight_layout()
plt.show()

"""Um score alto score é bom, é um baixo é ruim, onde 1 é perfeito.

Os gráficos comparam a inércia e o Silhouette Score para diferentes valores de clusters (k). A inércia diminui conforme k aumenta, sugerindo k = 4 como ponto de cotovelo. Já o Silhouette Score alcança o pico em k = 3, indicando clusters bem separados. Portanto, ambos os gráficos sugerem que entre 3 e 4 clusters seria uma escolha adequada para um bom agrupamento, mas como o primeiro gráfico indica 4, vamos seguir com K = 4!

## 8. 4-means clustering:
"""

# Agora podemos criar nosso modelo:

kmeans = KMeans(n_clusters = 4, random_state = 42, max_iter = 1000)

cluester_labels = kmeans.fit_predict(scaled_data_df)

cluster_labels

# Adicionando as clusters labels ao nosso conjunto de dados original:

non_outliers_df['Cluster'] = cluester_labels

non_outliers_df

"""Vemos que agora temos uma coluna so para os cluster aos quais os dados foram classificados!

## 9. Vizualizando os dados e tirando conclusões sobre eles:
"""

# Plotando o gráfico separando por cores:

cluster_colors = {0: '#1f77b4',  # Blue
                  1: '#ff7f0e',  # Orange
                  2: '#2ca02c',  # Green
                  3: '#d62728'}  # Red

colors = non_outliers_df['Cluster'].map(cluster_colors)

fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(projection='3d')

scatter = ax.scatter(non_outliers_df['MonetaryValue'],
                     non_outliers_df['Frequency'],
                     non_outliers_df['Recency'],
                     c=colors,  # Use mapped solid colors
                     marker='o')

ax.set_xlabel('Monetary Value')
ax.set_ylabel('Frequency')
ax.set_zlabel('Recency')

ax.set_title('3D Scatter Plot of Customer Data by Cluster')

plt.show()

# Violin Plots para cada variável

plt.figure(figsize=(12, 18))

plt.subplot(3, 1, 1)
sns.violinplot(x=non_outliers_df['Cluster'], y=non_outliers_df['MonetaryValue'], palette=cluster_colors, hue=non_outliers_df["Cluster"])
sns.violinplot(y=non_outliers_df['MonetaryValue'], color='gray', linewidth=1.0)
plt.title('Monetary Value by Cluster')
plt.ylabel('Monetary Value')

plt.subplot(3, 1, 2)
sns.violinplot(x=non_outliers_df['Cluster'], y=non_outliers_df['Frequency'], palette=cluster_colors, hue=non_outliers_df["Cluster"])
sns.violinplot(y=non_outliers_df['Frequency'], color='gray', linewidth=1.0)
plt.title('Frequency by Cluster')
plt.ylabel('Frequency')


plt.subplot(3, 1, 3)
sns.violinplot(x=non_outliers_df['Cluster'], y=non_outliers_df['Recency'], palette=cluster_colors, hue=non_outliers_df["Cluster"])
sns.violinplot(y=non_outliers_df['Recency'], color='gray', linewidth=1.0)
plt.title('Recency by Cluster')
plt.ylabel('Recency')

plt.tight_layout()
plt.show()

"""Os gráficos de violino mostram a distribuição dos valores monetários, frequência e recência para cada cluster identificado. O Cluster 2 se destaca com os maiores valores monetários e de frequência, indicando clientes de alto valor e engajamento. O Cluster 3 apresenta os menores valores, indicando clientes menos ativos. O Cluster 0 possui a maior recência, sugerindo clientes menos recentes. Cada cluster tem um perfil distinto que pode guiar estratégias de marketing personalizadas.

# **Análise de Clusters e Estratégias de Ação**

## **Cluster 0 (Azul): "Retenção"**  
**Justificativa:**  
Esse cluster representa clientes de **alto valor** que compram regularmente, embora não muito recentemente. O foco deve ser em mantê-los engajados para garantir sua lealdade e o nível de gastos.

**Ação:**  
- Implementar **programas de fidelidade**.  
- Oferecer **ofertas personalizadas**.  
- Realizar **comunicação frequente** para garantir que continuem ativos.

---

## **Cluster 1 (Laranja): "Reativação"**  
**Justificativa:**  
Esse grupo inclui clientes de **menor valor** que compram com **pouca frequência** e não fizeram **compras recentes**. O foco deve ser em trazê-los de volta ao ciclo de compras.

**Ação:**  
- Utilizar **campanhas de marketing direcionadas**.  
- Oferecer **descontos especiais**.  
- Enviar **lembretes** para incentivá-los a voltar a comprar.

---

## **Cluster 2 (Verde): "Nutrição"**  
**Justificativa:**  
Esse cluster representa clientes **menos ativos** e de **menor valor**, mas que fizeram **compras recentes**. Eles podem ser **novos clientes** ou precisar de mais atenção para aumentar o engajamento e os gastos.

**Ação:**  
- Focar no **desenvolvimento do relacionamento** com esses clientes.  
- Oferecer um **excelente atendimento ao cliente**.  
- Criar **incentivos** para aumentar a frequência de compras.

---

## **Cluster 3 (Vermelho): "Recompensa"**  
**Justificativa:**  
Esse cluster inclui clientes de **alto valor** que compram com **muita frequência** e continuam **ativos**. Eles são os clientes mais leais, e o foco deve

## 10. Lidando com os outliers de maneira separada:
"""

monetary_outliers_df
frequency_outliers_df

overlap_indices = monetary_outliers_df.index.intersection(frequency_outliers_df.index)

monetary_only_outliers = monetary_outliers_df.drop(overlap_indices)
frequency_only_outliers = frequency_outliers_df.drop(overlap_indices)
monetary_and_frequency_outliers = monetary_outliers_df.loc[overlap_indices]


monetary_only_outliers['Cluster'] = -1
frequency_only_outliers['Cluster'] = -2
monetary_and_frequency_outliers['Cluster'] = -3

outlier_clusters_df = pd.concat([monetary_only_outliers, frequency_only_outliers, monetary_and_frequency_outliers])

outlier_clusters_df

"""## 11. Vizualizando os dados e tirando conclusões sobre eles (outliers):"""

cluster_colors = {-1: '#9467bd',
                  -2: '#8c564b',
                  -3: '#e377c2'}

plt.figure(figsize=(12, 18))

plt.subplot(3, 1, 1)
sns.violinplot(x=outlier_clusters_df['Cluster'], y=outlier_clusters_df['MonetaryValue'], palette=cluster_colors, hue=outlier_clusters_df["Cluster"])
sns.violinplot(y=outlier_clusters_df['MonetaryValue'], color='gray', linewidth=1.0)
plt.title('Monetary Value by Cluster')
plt.ylabel('Monetary Value')

plt.subplot(3, 1, 2)
sns.violinplot(x=outlier_clusters_df['Cluster'], y=outlier_clusters_df['Frequency'], palette=cluster_colors, hue=outlier_clusters_df["Cluster"])
sns.violinplot(y=outlier_clusters_df['Frequency'], color='gray', linewidth=1.0)
plt.title('Frequency by Cluster')
plt.ylabel('Frequency')

plt.subplot(3, 1, 3)
sns.violinplot(x=outlier_clusters_df['Cluster'], y=outlier_clusters_df['Recency'], palette=cluster_colors, hue=outlier_clusters_df["Cluster"])
sns.violinplot(y=outlier_clusters_df['Recency'], color='gray', linewidth=1.0)
plt.title('Recency by Cluster')
plt.ylabel('Recency')

plt.tight_layout()
plt.show()

"""# **Análise dos Clusters de Outliers e Estratégias de Ação**

## **Cluster -1 (Monetary Outliers): "PAMPER"**  
### **Características:**  
Este grupo é composto por clientes que fazem **compras de alto valor**, mas de forma **infrequente**. Esses clientes não compram regularmente, porém quando o fazem, gastam significativamente. Eles têm um alto poder de compra e tendem a buscar **produtos de maior ticket médio**.

### **Estratégia Potencial:**  
- **Personalizar ofertas** que atendam ao perfil de compras desses clientes, como **serviços de luxo** ou **produtos exclusivos**.  
- Implementar **programas de retenção premium**, como brindes exclusivos ou acesso a produtos em pré-lançamento.  
- Focar em **manter a lealdade** desses clientes, oferecendo experiências diferenciadas que valorizem seu alto poder de compra, como **eventos privados** ou **acesso VIP**.

---

## **Cluster -2 (Frequency Outliers): "UPSELL"**  
### **Características:**  
Esse cluster inclui clientes que fazem **compras frequentes**, porém gastam **menos por transação**. Eles estão constantemente engajados com a marca, mas não aproveitam todo o potencial de consumo que possuem. Esses clientes são valiosos pelo volume de interações, mas existe uma oportunidade de **aumentar o ticket médio**.

### **Estratégia Potencial:**  
- **Implementar programas de fidelidade**, que incentivem esses clientes a gastar mais em cada compra.  
- Oferecer **promoções de pacotes ou combos**, destacando o benefício de compras maiores.  
- **Upselling**: Apresentar produtos complementares ou versões premium dos itens que já compram.  
- Criar campanhas que promovam o conceito de **"compre mais e economize"**, estimulando um aumento no valor médio gasto por compra.

---

## **Cluster -3 (Monetary & Frequency Outliers): "DELIGHT"**  
### **Características:**  
Este grupo representa os **clientes mais valiosos**. Eles combinam um alto volume de compras com **gastos significativos em cada transação**. Esses clientes provavelmente são os mais fiéis e têm um **alto nível de engajamento** com a marca. Eles já demonstram uma forte conexão e, por isso, precisam de **atenção especial** para manterem seu nível de lealdade.

### **Estratégia Potencial:**  
- Desenvolver **programas VIP exclusivos**, que ofereçam benefícios como **acesso antecipado a lançamentos**, **eventos privados**, **frete gratuito** ou **serviços personalizados**.  
- Criar **ofertas exclusivas** e **programas de reconhecimento** para esses clientes, mostrando que eles são valorizados.  
- **Manter o engajamento** por meio de **surpresas personalizadas**, como presentes de aniversário ou convites para eventos especiais.  
- Implementar um **sistema de atendimento premium**, garantindo que esses clientes tenham uma experiência diferenciada e única ao interagir com a marca.

---

## **Resumo das Estratégias por Cluster:**

| **Cluster**    | **Nome**     | **Características**                                          | **Estratégias**                                                              |
|----------------|--------------|----------------------------------------------------------------|------------------------------------------------------------------------------|
| **Cluster -1** | **PAMPER**    | Compradores de alto valor, mas infrequentes                   | Ofertas personalizadas, serviços de luxo, eventos VIP                        |
| **Cluster -2** | **UPSELL**    | Compradores frequentes, mas com baixo ticket médio            | Programas de fidelidade, promoções de pacotes, upselling                    |
| **Cluster -3** | **DELIGHT**   | Clientes mais valiosos, com compras frequentes e de alto valor | Programas VIP exclusivos, ofertas personalizadas, atendimento premium        |

---

## **Conclusão:**  
Esses clusters representam **outliers valiosos** que podem impulsionar significativamente o faturamento da empresa se forem gerenciados de forma estratégica. O **Cluster -1** precisa de retenção e personalização, o **Cluster -2** precisa de estratégias para aumentar o ticket médio, e o **Cluster -3** requer programas VIP para manter seu engajamento e lealdade. Focar nessas estratégias pode resultar em um **aumento expressivo da receita** e um **relacionamento mais forte** com os principais clientes da marca.
"""

cluster_labels = {
    0: "RETAIN",
    1: "RE-ENGAGE",
    2: "NURTURE",
    3: "REWARD",
    -1: "PAMPER",
    -2: "UPSELL",
    -3: "DELIGHT"
}

# Unindo os dois conjuntos de dados para ver melhor:

full_clustering_df = pd.concat([non_outliers_df, outlier_clusters_df])

full_clustering_df

# Criando uma coluna com as diferentes legendas:

full_clustering_df["ClusterLabel"] = full_clustering_df["Cluster"].map(cluster_labels)

full_clustering_df

"""## 12. Visualização:"""

cluster_counts = full_clustering_df['ClusterLabel'].value_counts()
full_clustering_df["MonetaryValue per 100 pounds"] = full_clustering_df["MonetaryValue"] / 100.00
feature_means = full_clustering_df.groupby('ClusterLabel')[['Recency', 'Frequency', 'MonetaryValue per 100 pounds']].mean()

fig, ax1 = plt.subplots(figsize=(12, 8))

sns.barplot(x=cluster_counts.index, y=cluster_counts.values, ax=ax1, palette='viridis', hue=cluster_counts.index)
ax1.set_ylabel('Number of Customers', color='b')
ax1.set_title('Cluster Distribution with Average Feature Values')

ax2 = ax1.twinx()

sns.lineplot(data=feature_means, ax=ax2, palette='Set2', marker='o')
ax2.set_ylabel('Average Value', color='g')

plt.show()

"""
## **Cluster "REWARD" (Maior grupo de clientes)**  
- **Número de Clientes:** Aproximadamente 1.400  
- **Recency:** Baixo, indicando que esses clientes compraram recentemente  
- **Frequency:** Média, sugerindo que compram com regularidade  
- **Monetary Value:** Alto, mostrando que esses clientes gastam consideravelmente

### **Interpretação:**  
O cluster "REWARD" representa os **clientes mais valiosos e leais**, que realizam compras frequentes e recentes, gerando um alto valor monetário. Esses clientes são essenciais para o negócio, e é importante mantê-los engajados por meio de **programas de fidelidade** e **ofertas exclusivas**.

---

## **Cluster "RE-ENGAGE" (Segundo maior grupo)**  
- **Número de Clientes:** Cerca de 1.000  
- **Recency:** Alto, indicando que esses clientes não compram há algum tempo  
- **Frequency:** Moderada, sugerindo que têm um histórico de compras, mas não estão ativos atualmente  
- **Monetary Value:** Baixo, indicando que não gastam tanto

### **Interpretação:**  
Esse cluster inclui clientes que **precisam ser reativados**. Eles compraram no passado, mas estão inativos. Estratégias como **campanhas de reengajamento**, **descontos personalizados** e **e-mails de lembrete** podem trazer esses clientes de volta.

---

## **Cluster "RETAIN" (Clientes regulares de valor moderado)**  
- **Número de Clientes:** Cerca de 900  
- **Recency:** Médio, sugerindo que compram regularmente, mas não tão recentemente quanto o cluster "REWARD"  
- **Frequency:** Moderada  
- **Monetary Value:** Moderado

### **Interpretação:**  
O cluster "RETAIN" é composto por clientes de valor **consistente**, que compram com certa frequência e geram receita moderada. O foco deve ser em **manter sua lealdade** por meio de **ofertas personalizadas** e **comunicações regulares**.

---

## **Cluster "NURTURE" (Clientes menos ativos)**  
- **Número de Clientes:** Cerca de 700  
- **Recency:** Alto, indicando que esses clientes não compram há bastante tempo  
- **Frequency:** Baixa  
- **Monetary Value:** Baixo

### **Interpretação:**  
O cluster "NURTURE" representa **clientes que precisam ser nutridos**. Eles fizeram poucas compras e estão inativos há muito tempo. Estratégias como **ofertas de boas-vindas**, **educação sobre os produtos** e **incentivos** podem ajudar a aumentar seu engajamento.

---

## **Cluster "DELIGHT" (Clientes de alto valor extremo)**  
- **Número de Clientes:** Aproximadamente 400  
- **Recency:** Baixo, indicando que compraram recentemente  
- **Frequency:** Alta, sugerindo que compram frequentemente  
- **Monetary Value:** Muito alto, o maior entre todos os clusters

### **Interpretação:**  
O cluster "DELIGHT" é composto pelos **clientes mais valiosos e engajados**, com o maior gasto e frequência de compra. Esses clientes são o **topo da pirâmide** e precisam de **tratamento VIP**, como **programas exclusivos**, **ofertas personalizadas** e **reconhecimento público de sua lealdade**.

---

## **Cluster "PAMPER" (Clientes de alto valor, mas infrequentes)**  
- **Número de Clientes:** Cerca de 300  
- **Recency:** Médio  
- **Frequency:** Baixa  
- **Monetary Value:** Alto

### **Interpretação:**  
O cluster "PAMPER" inclui clientes que gastam muito, mas fazem **poucas compras**. Esses clientes podem ser **compradores ocasionais**, buscando produtos de luxo ou compras específicas. Estratégias como **ofertas premium** e **acesso exclusivo** podem ajudar a **aumentar sua frequência de compras**.

---

## **Cluster "UPSELL" (Compradores frequentes de baixo ticket)**  
- **Número de Clientes:** Menos de 200, sendo o menor cluster  
- **Recency:** Médio  
- **Frequency:** Moderada  
- **Monetary Value:** Baixo

### **Interpretação:**  
O cluster "UPSELL" inclui clientes que fazem compras frequentes, mas com **baixo valor por transação**. Esses clientes são **bons candidatos para estratégias de upselling**, oferecendo produtos complementares ou promovendo pacotes para aumentar o ticket médio.

---

## **Insights Importantes:**  
1. O cluster **"REWARD"** é o mais populoso e representa os clientes mais leais, que precisam ser mantidos engajados.  
2. O cluster **"DELIGHT"** é o grupo mais valioso em termos de valor gerado.  
3. Os clusters **"RE-ENGAGE"** e **"NURTURE"** exigem esforços para reativação e engajamento.  
4. O cluster **"PAMPER"** requer atenção com ofertas personalizadas para aumentar a frequência de compras.  
5. O cluster **"UPSELL"** representa uma oportunidade clara de **aumentar o ticket médio** por meio de estratégias de upselling.

---

## **Conclusão:**  
O gráfico mostra que diferentes clusters têm **perfis distintos de comportamento**. A empresa pode **personalizar suas estratégias** de marketing e retenção de acordo com cada grupo, maximizando o engajamento e a receita. Clusters como "DELIGHT" e "REWARD" são **essenciais para a lucratividade**, enquanto "RE-ENGAGE" e "NURTURE" oferecem **potencial de crescimento** se reativados corretamente.
"""